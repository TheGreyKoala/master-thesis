\subsection{Aktualisierung einer Klassifikation}
    \label{section:solutionDetailsClassificationStorageAPIUpdatePage}
    Beim Aktualisieren einer Klassifikation muss die {\classificationStorageAPI}
    einige einige Sonderfälle beachten,
    um zum Beispiel die Idempotenz der Operation sicherzustellen.
    Dieses Kapitel beschreibt die notwendigen Maßnahmen und verwendet
    zur Veranschaulichung das Beispiel
    aus Kapitel \ref{section:solutionDetailPersistenceDataModelExample}.

    \paragraph{Arten einer Aktualisierung}
    Zur Beschreibung des Vorgehens bei einer Aktualisierung einer Klassifikation,
    wird zunächst die Frage beantwortet, welche Arten einer Änderung
    die {\classificationStorageAPI} unterscheidet.
    Dabei handelt es sich um die folgenden Szenarien:

    \begin{enumerate}
        \item Ein neues {\contentFeature} wurde auf einer beliebigen Ebene hinzugefügt.
        \item Eine Referenz zu einer bisher unbekannten {\resource} wurde auf einer beliebigen Ebene hinzugefügt.
        \item Eine Referenz zu einer bereits bekannten {\resource} wurde auf einer beliebigen Ebene hinzugefügt.
        \item Ein Feature inklusive seiner Child Features wurde auf einer beliebigen Ebene gelöscht.
        \item Die Klasse einer Seite wurde verändert.
    \end{enumerate}

    Änderung an Features, wie das Setzen einer anderen Klasse,
    interpretiert der Service als Löschung eines Features und Hinzufügen eines neuen Features.
    Im weiteren Verlauf dieses Kapitels wird deutlich werden,
    warum er sich so verhält und wieso das bei Seiten nicht der Fall ist.

    \paragraph{Herausforderung}
    Bei jeder Änderung den gesamten Graphen zu löschen und neu anzulegen,
    ist in­ef­fi­zi­ent und verursacht viele Operationen auf Datenträgern.
    Stattdessen versucht die {\classificationStorageAPI} den vorhandenen Graphen anzupassen,
    sodass er die übermittelte Klassifikation korrekt wiederspiegelt.
    Die Herausforderung dabei ist, dass der Service
    die einzelnen Schritte von der alten zur neuen Version der Klassifikation nicht verfolgen konnte.
    Stattdessen erhält er das fertige Ergebnis und muss diese Schritte selbst rekonstruieren.

    \paragraph{Lösungsidee}
    Anstatt die Differenz zwischen der alten und der neuen Klassifikation zu ermitteln,
    um entsprechende Anpassungsanweisungen zu generieren,
    begegnet die {\classificationStorageAPI} dieser Herausforderung auf eine andere Art und Weise.
    Sie führt auch in diesem Fall den Algorithmus aus Kapitel \ref{section:solutionDetailsStorageAPIInitialWrite}
    aus und generiert dabei Datenbankanweisungen,
    die nur bei Bedarf Änderungen an Knoten und Kanten vornehmen oder diese neu anlegen.
    Teilgraphen gelöschter Features sind dadurch leicht zu erkennen,
    was im weiteren Verlauf ersichtlich wird.
    Durch diese Methode ist der Algorithmus unabhängig vom aktuellen Datenbankzustand.
    Zwei Beispiele sollen die Idee verdeutlichen.

    \paragraph{Beispiel 1 -- Eine unveränderte Klassifikation}
    Zunächst wird der Fall betrachtet, dass eine Klassifikation unverändert erneut in die Datenbank geschrieben wird.
    Im Detail wird dazu das Feature \texttt{c1} aus dem Beispiel in Kapitel
    \ref{section:solutionDetailPersistenceDataModelExample} betrachtet.
    Zunächst wird für diesen Knoten festgestellt,
    dass ein \texttt{Text}-Knoten mit dem passenden Inhalt existiert und wiederverwendet werden kann.
    Ebenso existiert bereits ein passender \texttt{Content}-Knoten und eine \texttt{Reads}-Beziehung (\texttt{rel4}) zwischen diesen Knoten.
    Am Ende stellt der Algorithmus fest, dass sowohl der \texttt{Page}-Knoten als auch
    die Beziehung zu \texttt{c1} nicht neu angelegt werden müssen.
    Insgesamt hat der Algorithmus also die gesamte Klassifikation abgearbeitet
    und hat keine Schreiboperationen in der Datenbank durchgeführt.
    Diese Logik wird nicht durch den Kontrollfluss im Service umgesetzt,
    sondern durch die Datenbankanweisungen, die durch die Funktionen
    \texttt{contentNode},
    \texttt{contentRelationship},
    \texttt{pageNode},
    \texttt{referenceRelationship},
    \texttt{resourceNode}
    \texttt{textNode} und
    \texttt{textRelationship} in den Listings
    \ref{listing:storeClassificationPageFlow} und
    \ref{listing:storeClassificationContentReferenceFunctions}
    erzeugt werden.

    \paragraph{Beispiel 2 -- Eine veränderte Klassifikation}
    Nun wird an einem zweiten Beispiel gezeigt,
    wie das Vorgehen bei einer Änderung ist.
    Dazu wird angenommen, dass sich die Klasse von \texttt{c1} verändert hat.
    Wie zuvor wird der \texttt{Text}-Knoten wiederverwendet,
    da sich der Inhalt des Features nicht verändert hat.
    Anders als zuvor wird aber kein passender \texttt{Content}-Knoten gefunden,
    weshalb ein neuer Knoten \texttt{c1'} erzeugt wird, der die neuen Informationen enthält.
    Genauso wird eine neue Kante \texttt{rel4'} ausgehend von \texttt{c1'} zu \texttt{c1\_text} erzeugt.
    Am Ende wird der \texttt{Page}-Knoten wiederverwendet.
    Allerdings existiert keine Kante von \texttt{p} zu \texttt{c1'}.
    Diese wird deshalb in Form von \texttt{rel1'} angelegt,
    wohingegen \texttt{rel1}, die zum veralteten \texttt{c1} führt, gelöscht wird.
    Der Knoten \texttt{c1} ist nun verwaist, da er von keinem \texttt{Page}-Knoten erreichbar ist.
    Er kann daher inklusive \texttt{rel4} gelöscht werden.
    Im Falle neuer Features verhält sich der Service analog.

    \paragraph{Konsequenz für den Graphen}
    Das bis hierhin beschriebene Verfahren hat bereits eine wichtige
    Konsequenz für den Graphen.
    Sowohl \texttt{Text}- als auch \texttt{Content}-Knoten können nämlich mehrere einkommende Kanten besitzen.
    Für \texttt{Text}-Knoten ist das der Fall, wenn mehrere {\contentFeature}s mit dem gleichen textuellen Inhalt existieren.
    Für \texttt{Content}-Knoten, wenn es mehrere komplett identische {\contentFeature}s gibt.
    Das soll wiederum am Beispiel von \texttt{c1} verdeutlicht werden,
    welches die Überschrift der Seite \texttt{p} mit dem textuellen Inhalt "`Einstieg"' darstellt.
    Angenommen es existiert eine zweite Seite \texttt{p'},
    die ebenfalls diese Überschrift besitzt und die identisch klassifiziert wird.
    Das beschriebene Verfahren legt dann keinen neuen \texttt{Content}-Knoten an,
    sondern lediglich eine Kante, die von \texttt{p'} zu \texttt{c1} führt.
    Da der eindeutige Selektor des Features an der Kante gespeichert wird, ist das ohne Weiteres möglich.
    Genauso dürfen der Name des Features oder die Eigenschaft \texttt{isCollection} anders sein.
    Teilgraphen können also auf beliebigen Ebenen von mehreren Klassifikationen geteilt werden.
    Eine Abzweigung findet dabei immer an dem Punkt statt,
    ab dem sich die klassifizierten Seiten unterscheiden.
    Das wird im weiteren Verlauf noch deutlicher gezeigt.    
    Diese Eigenschaft ist nützlich für identische Inhalte
    verschiedener Webseiten, wie Kopf- oder Fußbereiche.
    Diese brauchen dann nur einmalig gespeichert werden.
    Außerdem macht der Graph diese Überschneidungen explizit wodurch sie leicht
    ermittelt werden können.
    % TODO: Was ist mit Resource Knoten? Die doch auch. Steht das irgendwo?

    \paragraph{Einschränkungen beim Teilen von Knoten}
    Das gerade beschriebene Teilen von Knoten ist nicht in jedem Fall gestattet.
    Es gibt drei Ausnahmen, die es zu behandeln gilt.

    \begin{enumerate}
        \item Es kann der Fall eintreten, dass zwei Klassifikationen Features besitzen,
        die sich lediglich im Namen eines {\childFeature}s unterscheiden,
        welches ansonsten aber ebenfalls identisch ist.
        In diesem Fall darf der Knoten des {\parentFeature}s nicht geteilt werden,
        was anhand eines Beispiels deutlich wird.
        Angenommen \texttt{c3} existiert identisch auf den Seiten \texttt{p} und \texttt{p'}.
        Auf der zweiten Seite besitzt \texttt{c3} ebenfalls ein Feature,
        welches \texttt{c5} exakt gleich ist.
        Allerdings heißt es auf dieser Seite \texttt{c5'}.
        Eine Wiederverwendung von \texttt{c3} hätte in diesem Fall zur Folge,
        dass zwei Kanten zwischen \texttt{c3} und \texttt{c5} existieren würden,
        deren einziger Unterschied die Eigenschaft \texttt{name} wäre.
        Mit dem verwendeten Datenmodell wäre es nicht möglich festzustellen,
        welche Kante zu welcher Klassifikation gehört,
        d. h. welche Klassifikation das Feature \texttt{c5} und welche \texttt{c5'} nennt.
        Anstelle die jeweilige \gls{url} der Seite in den Kanten zu speichern,
        erzeugt der Algorithmus für \texttt{p'} eine Kopie von \texttt{c3}
        und eine Kante von diesem neuen Knoten zu \texttt{c5},
        welche den Namen \texttt{c5'} speichert.
        \item Durch die Änderung eines Features kann es außerdem passieren,
        dass ein zuvor geteilter Knoten nicht mehr geteilt werden darf.
        Oben wurde der Fall beschrieben, dass \texttt{c1}
        von zwei Klassifikationen verwendet wird.
        Falls sich der Text der Überschrfit auf \texttt{p'} ändert,
        ist \texttt{c1\_text} nicht mehr für beide Seiten zutreffend.
        Der Inhalt dieses \texttt{Text}-Knotens darf aber nicht angepasst werden,
        weil er für \texttt{p} weiterhin korrekt ist.
        Der Algorithmus legt deshalb eine Kopie von \texttt{c1\_text} und \texttt{c1} an
        und erzeugt entsprechende Verbindungen zwischen ihnen und zu \texttt{p'}.
        \item Der letzte Sonderfall tritt für ein Parent Feature ein,
        sobald sich irgendeins seiner Child Features verändert hat.
        Das heißt, es ist ein neues Child Feature hinzugekommen oder
        ein bestehendes wurde verändert bzw. gelöscht.
        Das betroffene Child Feature darf nicht angepasst werden,
        da es in der jetzigen Form noch von anderen Seiten benötigt werden könnte.
        Das Parent Feature muss in diesem Fall dupliziert werden,
        sodass die Kopie die Änderung am Child Feature beinhalten kann,
        ohne das Original zu beeinträchtigen.
        Auch dieser Fall lässt sich gut veranschaulichen.
        Angenommen die Seiten p und p' referenzieren beide c3 und teilen sich damit
        dieses Feature inklusive seiner Child Features.
        Ändert sich nun beispielsweise die Klasse von c5 auf p',
        ist das Vorgehen folgendermaßen:
        Nachdem festgestellt wurde, dass r1, r2 und c5\_text wiederverwendet werden können,
        wird ein neuer Knoten c5' angelegt, der die neue Klasse enthält
        und die zuvor genannten Knoten analog zu c5 referenziert.
        Anschließend erstellt der Algorithmus c3', eine exakte Kopie von c3,
        der ausgehende Kanten zu c4 und c5' erhält.
        Abschließend wird eine Kante von p' zu c3' erstellt und die Kante zu c3 dafür gelöscht.
        Durch diese letzte Prämisse ist auch der Fall abgedeckt,
        dass ein Feature gelöscht wurde.
    \end{enumerate}

    \paragraph{Abschließende Operationen}
    Der einzige offene Punkte der Liste am anfang des Kapitels ist die Änderung der Klasse der Seite.
    Dieser kann sehr einfach begegnet werden, indem die Klasse der Seite jedes mal neu gesetzt wird.
    Nach der Ausführung des beschriebenen Algorithmus kann die Datenbank
    Content- und {\resource}-Knoten enthalten, die keine eingehenden Knoten besitzen.
    Sie verletzen nicht die Konsistenz irgendeiner Klassifikation, da sie verwaist sind,
    sind aber trotzdem überflüssig.
    Aus diesem Grund setzt der Algorithmus abschließend eine Anweisung an die Datenbank,
    die Teilgraphen sucht, die von keiner Seite aus erreichbar sind, und löscht.
    Außerdem wird ein Knoten für die Site sowie eine Kante zur Seite sichergestellt.

    \paragraph{Datenbankanweisungen}
    Wie bereits erwähnt wurde, wird die oben beschriebene Logik nicht innerhalb
    des Services umgesetzt, sondern durch die Datenbankanweisungen, die es generiert.
    Deshalb sollen diese Anweisungen ebenfalls kurz erläutert werden.
    
    Eine Schlüsselrolle spielt das MERGE-Statement,
    welches Muster im Graphen sucht und bei Bedarf anlegt.
    %TODO: Referenz: https://neo4j.com/docs/developer-manual/3.3/cypher/clauses/merge/
    Die in Listing \ref{listing:storeClassificationContentReferenceFunctions} genutzten
    Funktionen textNode und resourceNode erzeugen deshalb simple Anweisungen:
    \texttt{MERGE (t:Text {value: \$t.value})} und \texttt{MERGE (r:Resource {url: \$r.destination})},
    wobei "`\$t"' und "`\$r"' Objekte sind, die der Datenbank inklusive der Anweisungen übergeben werden.
    Die Eigenschaften "`value"' bzw. "`url"' dienen also der eindeutigen Identifizierung von
    Text- und {\resource}-Knoten, was auch schon in Kapitel
    \ref{section:solutionDetailsPersistenceDataModel} erklärt wurde
    und weshalb diese Eigenschaft über Unique Property Constraints sichergestellt wird
    (siehe Kapitel \ref{section:solutionDetailsPersistenceDatabse}).

    Für Content Nodes wird die Anweisung
    \texttt{MERGE (c:Content {checksum: \$c.checksum, class: \$c.class})} erzeugt,
    wobei die Checksumme das eigentliche Kriterium der eindeutigen Identifizierung darstellt.
    Die Anweisung muss alle Child Features abdecken, damit im Falle einer Differenz eines Childs,
    auch die Beziehungen zu den restlichen Childs vom kopierten Parent ausgehend angelegt werden.
    Bei separaten Anweisungen für jedes Child Feature, wäre das nicht möglich.
    Die Checksumme wird deshalb über das gesamte {\contentFeature} inklusive aller seiner Child Features gebildet.
    Andere Methoden, um dies zu erreichen, erweisen sich als zu komplex und ineffizient.
    Der Grund dafür ist die eindimensionale Natur eines MERGE-Statements.
    Dadurch ist es nicht möglich ein einzelnes Statement zu formulieren,
    dass n ausgehende Kanten zu n verschiedenen Knoten matcht.
    Mehrere Kanten und Knoten können nur über verallgemeinerte Statements gematcht werden,
    was für den vorliegenden Fall nicht ausreichend ist.
    Mit MERGE-Statements können aber auch Ketten der Form a-b-c formuliert werden,
    was auf den ersten Blick eine Alternative zur Prüfsumme darstellt.
    Nämlich dann, wenn neben der ausgehenden Kante vom Parent zum Child Feature,
    auch eine "`Rückkante"' vom Child zum Parent existieren würde.
    Dann könnte eine Kette der Form parent-child1-parent-child2-parent-child3 formuliert werden.
    Allerdings hilft das nicht im Falle eines gelöschten Child Features weiter,
    da dieses nicht in der Kette auftaucht, die aber trotzdem gefunden wird.
    Um diesen Fall abzufangen müssten die Child Features zusätzlich einen Ring bilden,
    wodurch allerdings ihre Position in der Kette relevant werden würde.
    Insgesamt ist dieser Ansatz nicht sinnvoll umsetzbar,
    weshalb die sich für die Prüfsumme entschieden wurde.

    Diese Prüfsumme und ihre Eindeutigkeit machen sich auch die Funktionen
    contentRelationship, referenceRelationship und textRelationship zunutze.
    Mit dieser Eigenschaft und der jeweiligen eindeutigen Eigenschaft des zweiten
    Knotens, können sie MATCH-Statements formulieren,
    die die beiden Knoten einer Beziehung finden.
    Anschließend wird zwischen diesen Knoten wiedrum ein MERGE generiert,
    der die gewünschte Beziehung zwischen ihnen beschreibt.
    Dies gilt analog auch für Seiten-Knoten, ihrer eindeutigen \gls{url}
    und ihre ausgehenden Beziehungen.
    Außerdem werden dadurch die oben beschriebenen Ausnahmen für das Teilen von Knoten sehr leicht händelbar.
