\section{Ausblick}
    \label{section:endingOutlook}
    Das \gls{wccs} kann an vielen Stellen sinnvoll erweitert werden.

    \paragraph{Vererbung}
    Eine Erweiterung, von der die \gls{wccdl} profitieren würde,
    ist die Einführung eines Vererbungskonzeptes für Klassen,
    um Features und Selektoren wiederzuverwenden und die Ausdrucksstärke
    der Sprache zu erhöhen.
    Hierzu muss ein konsistentes Konzept für Vererbung und Polymorphie
    von Features und Selektoren geschaffen werden,
    welches sich syntaktisch gut einfügt.
    Außerdem erfordert es weitergehende semantische Prüfungen.

    \paragraph{Eingebettete Klassendefinitionen}
    Ein Grund der schwachen Ausdrucksstärke der Sprache ist die Notwendigkeit,
    jede Klasse einzeln bekannt machen zu müssen.
    Dem könnte durch die Einführung eingebetteter Klassendefinitionen begegnet werden.
    Einmalig genutzte Klassen ohne Features können dadurch bei ihrer Verwendung
    definiert werden.
    Die Definition eines Features könnte dann folgendermaßen aussehen:

    \lstinputlisting[
        caption=Ein Ausblick auf eingebettete Klassendefinitionen in der \acrshort{wccdl},
        label=listing:outlookEmbeddedClasses,
        inputencoding=utf8/latin1,
        style=wccdl
    ]{../resources/outlook/embedded-classes.wctd}

    \paragraph{Syntaktische Prüfung von Selektoren}
    Interessant ist außerdem die Einbettung
    von Sprachen zur Unterstützung von CSS-, XPath- und regulären Ausdrücken,
    sodass Selektoren syntaktisch überprüft werden können
    und ihre Formulierung durch die Entwicklungsumgebung unterstützt wird.

    \paragraph{Einfachere Formulierung von Selektoren}
    Der Entwickler könnte außerdem durch ein Browser-Plugin
    deutlich bei der Formulierung von Selektoren unterstützt werden.
    Nämlich dann, wenn dieses Plugin den Browser und die Entwicklungsumgebung
    dahin gehend verbindet, dass der Browser solche Elemente auf der aktuellen Webseite
    hervorhebt, die durch einen bestimmten Selektor im {\classificationModel} erfasst werden.
    Andersherum könnte der Entwickler den Browser nutzen,
    um einen Selektor eines \gls{html}-Elementes zu bestimmen und
    in die Entwicklungsumgebung zu übertragen.

    \paragraph{Neue Selektortypen}
    Eine Möglichkeit die beschriebenen Sonderfälle besser abzudecken ist die
    Einführung eines Skript-Selektors,
    da sich programmatisch auch deutlich komplexere Strukturen klassifizieren lassen sollten.
    Zur Auswahl eines \gls{html}-Elementes oder von Text würde also ein Stück JavaScript ausgeführt werden.
    Dank der Browserautomatisierung durch Puppeteer ist dies möglich.

    \paragraph{Auswertung mehrerer Selektoren pro Feature}
    Eine weitere Maßnahme zu diesem Zweck ist die Einführung von Selektorketten.
    Ein Feature kann dann durch eine sequenziell ausgeführte Reihe von Selektoren
    ermittelt werden, wobei das Ergebnis eines Selektors als Kontextelement des nächsten fungiert.
    Dadurch lässt sich der Suchraum mit verschiedenen Selektortypen eingrenzen,
    ohne zusätzliche Features definieren zu müssen.

    \paragraph{Maschinelles Lernen}
    In Kapitel \ref{section:discussionComparisonClassificationSystem}
    wurde das Thema maschinelles Lernen bereits kurz aufgegriffen.
    Im \gls{wccs} sind zwei Anwendungen dieser Technik denkbar:

    \begin{enumerate}
        \item   Das System wird anhand einiger Klassifikationen trainiert
                und versucht anschließend ohne exakte Vorgaben (Selektoren),
                sondern nur auf Basis des Trainings,
                neue Seiten zu erkennen und zu strukturieren.
        \item   Das System analysiert Korrekturen, die durch Nutzer durchgeführt werden
                und erzeugt Vorschläge für Änderungen in weiteren Klassifikationen.
    \end{enumerate}

    \paragraph{Anlegen und Löschon von Annotationen}
    Der Nutzen des {\annotatorPlugin}s kann deutlich erhöht werden,
    indem das Löschen und Anlegen von Annotationen unterstützt wird.
    Außerdem wäre es denkbar, neben den vordefinierten Klassen auch
    die Angabe eigener neuer Klassen zu erlauben.
