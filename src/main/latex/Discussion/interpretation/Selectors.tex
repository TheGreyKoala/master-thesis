\subsection{Mächtigkeit der Selektoren}
    \label{section:discussionInterpretationSelectors}
    Zusammen mit der Schachtelung von Features und dem
    damit verbundenen eingeschränkten Kontexts bei der
    Auswertung von Selektoren,
    spielen deren Fähigkeiten eine zentrale Rolle bei den
    Möglichkeiten der Klassifizierung, die das \gls{wccs} bietet.
    Betrachtet man die {\classificationModel}e der beiden Fallbeispiele wird klar,
    dass ohne den {\xpathSelector} die Möglichkeiten weitaus eingeschränkter wären.
    Die Klasse \texttt{Portal}, durch die ein Feature das Kontextelement
    als {\referenceFeature} \texttt{homepage} klassifiziert,
    wäre beispielsweise weder mit dem {\cssSelector}
    noch mit dem {\urlSelector} möglich.
    Beide können ausschließlich untergeordnete Elemente erfassen.
    Die Selektoren und die Art ihrer Verwendung hat allerdings auch Grenzen.
    Ein Beispiel sind die Mitarbeiter, deren Namen laut Klassifikation
    "`Prof."' bzw. "`Dr."' sind.
    Ein ähnliches Problem gibt es im zweiten Beispiel bei den Absätzen einer Meldung,
    von denen es unterschiedlich viele geben kann.
    In beiden Fällen lässt sich argumentieren,
    dass mehrere HTML-Elemente zusammen eine Einheit darstellen
    und dass ihr textueller Inhalt deshalb
    in einem skalaren Feature gespeichert werden sollten.
    Anders also als {\collectionFeature}s,
    bei denen jedes Element für sich eine eigenständige Einheit darstellt.
    Die beschriebene Anforderung lässt sich bisher nur umsetzen,
    wenn die übergeordnete Einheit der Elemente durch ein gemeinsames
    Vaterelement dargestellt wird, welches nur genau diese Element enthält.
    Für das erste Beispiele hieße die Anforderung, dass der Selektor des Namens eines Mitarbeiters
    alle relevanten Elemente erfasst und
    das \gls{wccs} die textuellen Werte dieser Elemente
    in einem skalaren Feature speichert.
    Der eindeutige Selektor dieses Features würde alle Elemente umfassen,
    was prinzipiell schon jetzt möglich ist,
    da der Selektor Start- und Endelemente unterscheidet.

    Das zweite Fallbeispiel zeigt eine weitere Grenze des Systems,
    da es nicht möglich ist einen allgemeinen Selektor zu formulieren,
    der die Absätze pro Nachricht korrekt
    erfasst.
    Allgemein ausgedrückt ist eine sinnvolle Klassifizierung nicht möglich,
    wenn ein Element eines {\collectionFeature}s selbst ein {\collectionFeature} besitzt
    und weder das Parent- noch das {\childFeature} alleine in einem Element gekapselt ist.
    Diese Einschränkung ist durch die verwendeten Selektortypen begründet.
    Eine Erweiterung des Systems durch andere Selektortypen, kann diese Lücke
    füllen\footnote{vgl. Kapitel \ref{section:endingOutlook}}.

    Die Entscheidung als Ergebnis eines {\xpathSelector}s auch reinen Text und nicht nur
    HTML-Elemente zu akzeptieren, bringt deutliche Vorteile für das \gls{wccs}.
    Es erlaubt z. B. die Telefonnummer eines Mitarbeiters zu selektieren,
    was sonst nicht möglich wäre, da sie nicht alleine in einem Element steht.
    Allerdings darf in diesem Fall die Bestimmung der Versatzangabe des Startelementes nicht auf
    Basis der Eigenschaft \texttt{innerText} geschehen.
    Wie bei der falsch annotierten Telefonnummer im Portal \gls{bapvs} deutlich
    wird,
    muss der durch XPath ermittelte Text nicht in derselben Form im \texttt{innerText} eines Elementes auftauchen.
    Der zu durchsuchende Text muss deshalb ebenfalls über XPath ermittelt werden.
    Für Drittsystemen wird dadurch die Auswertung eines eindeutigen Selektors allerdings komplexer.
