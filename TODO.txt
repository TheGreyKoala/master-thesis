!- Kapitel 1+2 überarbeiten
!- Alle Kapitel schön schreiben
!- Deckblatt
?- Spezifikation der APIs erstellen und in Anhang
?- JSON-Schema für DSL Generat & Page Objekt?
!- Im Konzeptkapitel steht, dass Features in einer Collection alle dieselbe Klasse haben, aber durch die Möglichkeit der Nachbesserung kann das umgangen werden!
!- Beschriftungen von Bildern etc. checken
!- Ganzes Dokument auf Rechtschreibfehler prüfen
!- TODOs im Quelltext

!- Ganzes System nochmal durchtesten
!- Auslieferung zusammenpacken
!-- Wie funktioniert das mit Xtext?
!-- Versionsnummern
?-- Namen der Services etc.

- Classification Storage API
!- Page Objekte haben noch types
!- Neo4J Passwort ist hart codiert
!- Labels und Properties in der DB heißen noch falsch

- Classification Service
!- Konfigurationsdatei hat doofen Namen (besser: classification-model.json)
!- Warum bricht der Browser schon bei 4 parallelen Seiten zusammen?

- Storage
!- Volume für Neo4J
!- Indexe auf neue Namen, sobald in Storage API gefixt

- Annotator Plugin
!- if-Prüfung in Zeile 43 doof. Was, wenn annotation.wccs schon fehlt?
!- Wofür war die Anpassung in annotator-full.js? Die Macht das neue XPath Feature kaputt.
    --> Ohne diesen Fix scheinen die Annotationen der Antworten der FAQs nicht angezeigt zu werden.
!- Muss die Funktion zum Anlegen neuer Annotationen noch deaktiviert werden? Der Service unterstützt das nicht!

- Annotation Service
!- Annotationen haben noch property in featureKind
!- ID einer Annotation enthält noch "properties"

- Sprache
?- Wenn in XPath ein String angegeben wird und darin ein \n, wird das zu viel escaped.

- Web App
!- In den Labels steht noch "Type"
?- Sollte die Detailseite auch die Selektoren und isCollection der Features beinhalten?

- Crawler
-- Es steht an vielen Stellen noch wcts (z. B. die ausführbaren Skripte)

- Ist es "Klassifizierungsmodell" oder "Klassenmodell"? Betrifft viele Stellen.

- Selektor eines Features in Beziehung zu speichern, trägt nicht zur Wiederverwendbarkeit Beziehung
-- Selektor ist immer absolut. Er enthält kompletten Pfad seines Parent Features.
-- Wenn ein Feature x zwei eingehende Kanten hat, dann heißt das, dass die Seiten ab hier identisch sind. Inkl. der _absoluten_ Selektoren der Child Features.
-- D.h. aber auch, dass Selektoren in eingehenden Kanten von x identisch sein müssen.
-- Andernfalls wären die absoluten Selektoren der Child Features nicht identisch.
-- Selektoren von Features müssen relativ zum Parent Feature sein.
-- Falls x zwei eingehende Kanten hat, dann heißt das:
--- x ist in beiden Seiten an exakt der gleichen Stelle (xpath) zu finden
--- Die anderen Kinder seiner Parent Features unterscheiden sich oder x ist ein mal ein ScalarFeature und ein mal ein CollectionFeature.
--- Sonst wären auch Parent Features identisch
- Interessanterweise wird auch die Checksumme bereits über das gesamte Feature (d.h. inkl. Selektor) gebildet.

- Graphdatenbank macht auch Probleme
-- Beim Schreiben einer Seite müssen immer viele Nodes betroffen und es ist schwer festzustellen, was angepasst und gelöscht werden muss*
-- Lesen einer Seite kompliziert
-- Durch geteilte Nodes können Änderungen nicht "einfach so" gemacht werden
--> Das ist aber generell bei allen Datenbank so, die die einzelnen Teile getrennt speicher (z. B. auch in relationaler DB)
--> Wäre nur in Document Store (z. B. Mongo anders)
* Das übernehmen sonst z. B. OR-Mapper
--> Es ist schwierig, weil die Operationen, die vom alten zum neuen führen (Diff) manuell ermittelt werden müssen


Done oder nicht mehr nachvollziehbar:
=====================================
- Klassen werden in DSL definiert.
-- Ich mache eine Klasse nicht nur bekannt (Deklaration), sondern beschreibe auch, woraus sie besteht
?-- Muss in DSL in den Namen der Regeln angepasst werden

x GENERIERUNG SOLL JSON ERSTELLEN! REQUIRE FUNKTION KANN JSON EINLESEN!
x Generiertes JSON muss überarbeiet werden, sodass es nicht mehr "type" enhält
x Feste Versionsnummern für verwendete Images

- Classification Storage API
x!-- Es wird POST auf /sites/{id}/pages zum Schreiben verwendet
x---- Das ist falsch, weil wir eine ID vorgeben wollen und Requests idempotent sein sollen
x---- POST ist nicht idempotent sondern soll _immer_ anlegen
x---- Muss umgestellt werden auf PUT /sites/{id}/pages/{page-id}

x!- Abstract
x!- Lösungskonzept
x!- Lösungsdetails
x!- Ergebnisse
x!- Diskussion der Ergebnisse
x!- Schluss
x!- Grundlagen zu Microservices
x!- Grundlagen zu DSLs
x!- Grundlagen zu Xtext
x!- Grundlagen zu Graphdatenbanken


- Crawler
x!- Findet der Crawler auch http://www.fernuni-hagen.de/KSW/portale/babw/service/aktuelles/page/2/
    --> NEIN