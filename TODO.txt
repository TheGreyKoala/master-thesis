- Klassen werden in DSL definiert.
-- Ich mache eine Klasse nicht nur bekannt (Deklaration), sondern beschreibe auch, woraus sie besteht
!-- Muss in DSL in den Namen der Regeln angepasst werden

!- Grundlagen zu Microservices
!- Grundlagen zu DSLs
!- Grundlagen zu Xtext
!- Grundlagen zu Graphdatenbanken

!- GENERIERUNG SOLL JSON ERSTELLEN! REQUIRE FUNKTION KANN JSON EINLESEN!
!- Generiertes JSON muss überarbeiet werden, sodass es nicht mehr "type" enhält

?- Spezifikation der APIs erstellen und in Anhang
?- JSON-Schema für DSL Generat & Page Objekt?
!- Ganzes System nochmal durchtesten
!- Auslieferung zusammenpacken
!-- Wie funktioniert das mit Xtext?
!-- Versionsnummern
?-- Namen der Services etc.

- Classification Storage APIs
-- Es wird POST auf /sites/{id}/pages zum Schreiben verwendet
-- Das ist falsch, weil wir eine ID vorgeben wollen und Requests idempotent sein sollen
-- POST ist nicht idempotent sondern soll _immer_ anlegen
!-- Muss umgestellt werden auf PUT /sites/{id}/pages/{page-id}

!- Neo4J Passwort ist hart codiert
!- Volume fü Neo4J
!- Konfigurationsdatei für Classification Service hat doofen Namen

- Selektor eines Features in Beziehung zu speichern, trägt nicht zur Wiederverwendbarkeit Beziehung
-- Selektor ist immer absolut. Er enthält kompletten Pfad seines Parent Features.
-- Wenn ein Feature x zwei eingehende Kanten hat, dann heißt das, dass die Seiten ab hier identisch sind. Inkl. der _absoluten_ Selektoren der Child Features.
-- D.h. aber auch, dass Selektoren in eingehenden Kanten von x identisch sein müssen.
-- Andernfalls wären die absoluten Selektoren der Child Features nicht identisch.
-- Selektoren von Features müssen relativ zum Parent Feature sein.
-- Falls x zwei eingehende Kanten hat, dann heißt das:
--- x ist in beiden Seiten an exakt der gleichen Stelle (xpath) zu finden
--- Die anderen Kinder seiner Parent Features unterscheiden sich oder x ist ein mal ein ScalarFeature und ein mal ein CollectionFeature.
--- Sonst wären auch Parent Features identisch


- Graphdatenbank macht auch Probleme
-- Beim Schreiben einer Seite müssen immer viele Nodes betroffen und es ist schwer festzustellen, was angepasst und gelöscht werden muss*
-- Lesen einer Seite kompliziert
-- Durch geteilte Nodes können Änderungen nicht "einfach so" gemacht werden
--> Das ist aber generell bei allen Datenbank so, die die einzelnen Teile getrennt speicher (z. B. auch in relationaler DB)
--> Wäre nur in Document Store (z. B. Mongo anders)
* Das übernehmen sonst z. B. OR-Mapper
--> Es ist schwierig, weil die Operationen, die vom alten zum neuen führen (Diff) manuell ermittelt werden müssen